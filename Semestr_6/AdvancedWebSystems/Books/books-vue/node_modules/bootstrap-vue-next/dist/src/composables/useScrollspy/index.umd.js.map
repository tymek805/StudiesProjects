{"version":3,"file":"index.umd.js","sources":["../../../../src/composables/useScrollspy/index.ts"],"sourcesContent":["import {syncRef, useIntersectionObserver, useMutationObserver} from '@vueuse/core'\nimport {\n  type ComponentPublicInstance,\n  computed,\n  getCurrentInstance,\n  type MaybeRefOrGetter,\n  nextTick,\n  onMounted,\n  readonly,\n  type Ref,\n  ref,\n  toRef,\n  watch,\n} from 'vue'\nimport {getElement} from '../../utils/getElement'\n\ntype ScrollspyList = {\n  id: string | null\n  el: HTMLElement | null\n  visible: boolean\n  text: string | null\n}[]\n\ninterface ScrollspyReturn {\n  current: Readonly<Ref<string | null>>\n  list: Readonly<Ref<ScrollspyList>>\n  content: Ref<HTMLElement | undefined>\n  target: Ref<HTMLElement | undefined>\n  scrollIntoView: (event: MouseEvent) => void\n  updateList: () => void\n  cleanup: () => void\n}\n\ninterface ScrollspyOptions {\n  contentQuery: string\n  targetQuery: string\n  manual: boolean\n  root: string | ComponentPublicInstance | HTMLElement | null\n  rootMargin: string\n  threshold: number | number[]\n  watchChanges: boolean\n}\n\nexport const useScrollspy = (\n  content: MaybeRefOrGetter<string | ComponentPublicInstance | HTMLElement | null>,\n  target: MaybeRefOrGetter<string | ComponentPublicInstance | HTMLElement | null>,\n  options: Readonly<Partial<ScrollspyOptions>> = {}\n): ScrollspyReturn => {\n  const cont = toRef(content)\n  const tar = toRef(target)\n\n  const resolvedContent = ref(getElement(cont.value))\n  const resolvedTarget = ref(getElement(tar.value))\n\n  watch([cont, tar], () => {\n    updateList()\n  })\n  const {\n    contentQuery = ':scope > [id]',\n    targetQuery = '[href]',\n    manual = false,\n    root,\n    rootMargin = '0px 0px -25%',\n    threshold = [0.1, 0.5, 1],\n    watchChanges = true,\n  } = options\n  const current = ref<string | null>(null)\n  const list = ref<ScrollspyList>([])\n  const nodeList = ref<HTMLElement[]>([])\n\n  // are we called in directive?\n  const ctx = getCurrentInstance()\n  if (!ctx) {\n    nextTick(() => {\n      updateList()\n    })\n  } else {\n    onMounted(() => {\n      syncRef(cont, resolvedContent, {\n        transform: {\n          ltr: (v) => getElement(v),\n        },\n        direction: 'ltr',\n        immediate: true,\n      })\n      syncRef(tar, resolvedTarget, {\n        transform: {\n          ltr: (v) => getElement(v),\n        },\n        direction: 'ltr',\n        immediate: true,\n      })\n      updateList()\n    })\n  }\n\n  const updateList = () => {\n    nodeList.value = resolvedContent.value\n      ? (Array.from(resolvedContent.value.querySelectorAll(contentQuery)) as HTMLElement[])\n      : []\n    list.value = nodeList.value.map((el) => ({\n      id: el.id,\n      el,\n      visible: false,\n      text: el.textContent,\n    }))\n  }\n\n  let isScrollingDown = true\n  let previousScrollTop = 0\n  const scrollRoot = computed(() =>\n    resolvedContent.value && getComputedStyle(resolvedContent.value).overflowY === 'visible'\n      ? null\n      : resolvedContent.value\n  )\n\n  const iobs = useIntersectionObserver(\n    nodeList,\n    (entries) => {\n      const scrollTop = (scrollRoot.value || document?.documentElement)?.scrollTop\n      isScrollingDown = scrollTop > previousScrollTop\n      previousScrollTop = scrollTop\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          list.value.forEach((node) => {\n            if (node.el === entry.target) {\n              node.visible = true\n            }\n          })\n          return\n        }\n        list.value.forEach((node) => {\n          if (node.el === entry.target) {\n            node.visible = false\n          }\n        })\n      })\n      let newId: string | null = null\n      if (isScrollingDown) {\n        newId = [...list.value].reverse().find((node) => node.visible)?.id || null\n      } else {\n        newId = list.value.find((node) => node.visible)?.id || null\n      }\n      if (newId !== null) {\n        current.value = newId\n      }\n      if (!current.value) {\n        current.value = list.value[0]?.id || null\n      }\n    },\n    {\n      root: root ? getElement(root) : scrollRoot,\n      rootMargin,\n      threshold,\n    }\n  )\n  watch(current, (newId) => {\n    if (manual) return\n    const nodes = resolvedTarget.value?.querySelectorAll(targetQuery)\n    if (nodes === undefined) return\n    let foundParent = false\n    let activeElement: HTMLElement | null = null\n    nodes.forEach((node) => {\n      const parentDropdown = node.closest('.dropdown')\n\n      if (node.getAttribute('href')?.includes(`#${newId}`)) {\n        activeElement = node as HTMLElement\n        node.classList.add('active')\n        if (parentDropdown) {\n          parentDropdown?.querySelector('.dropdown-toggle')?.classList.add('active')\n          foundParent = true\n        }\n        let parentNav = node.closest('.nav')?.previousSibling as HTMLElement\n        while (parentNav?.classList?.contains('nav-item')) {\n          foundParent = true\n          parentNav.querySelector('.nav-link')?.classList.add('active')\n          parentNav = parentNav.closest('.nav')?.previousSibling as HTMLElement\n        }\n      } else {\n        node.classList.remove('active')\n        if (parentDropdown && !foundParent) {\n          parentDropdown?.querySelector('.dropdown-toggle')?.classList.remove('active')\n        }\n\n        if (!foundParent) {\n          let parentNav = node.closest('.nav')?.previousSibling as HTMLElement\n          while (parentNav?.classList?.contains('nav-item')) {\n            foundParent = true\n            if (parentNav.querySelector('.nav-link') !== activeElement) {\n              parentNav.querySelector('.nav-link')?.classList.remove('active')\n            }\n            parentNav = parentNav.closest('.nav')?.previousSibling as HTMLElement\n          }\n        }\n      }\n    })\n  })\n\n  const mobs = !watchChanges\n    ? {stop: () => {}}\n    : useMutationObserver(\n        resolvedContent,\n        () => {\n          updateList()\n        },\n        {\n          childList: true,\n        }\n      )\n  const scrollIntoView = (event: Readonly<MouseEvent>, smooth: boolean = false) => {\n    event.preventDefault()\n    const href = (event.target as HTMLElement)?.getAttribute?.('href')\n    const el: HTMLElement | null = href ? document?.querySelector(href) : null\n    // console.log('scrollIntoView', event, el, content.value.$el)\n    if (el && resolvedContent.value) {\n      if (resolvedContent.value.scrollTo) {\n        resolvedContent.value.scrollTo({top: el.offsetTop, behavior: smooth ? 'smooth' : 'auto'})\n      } else {\n        resolvedContent.value.scrollTop = el.offsetTop\n      }\n    }\n  }\n  const cleanup = () => {\n    iobs.stop()\n    mobs.stop()\n  }\n  return {\n    current: readonly(current),\n    list,\n    content: resolvedContent,\n    target: resolvedTarget,\n    scrollIntoView,\n    updateList,\n    cleanup,\n  }\n}\n"],"names":["content","target","options","cont","toRef","tar","resolvedContent","ref","getElement","value","resolvedTarget","watch","updateList","contentQuery","targetQuery","manual","root","rootMargin","threshold","watchChanges","current","list","nodeList","getCurrentInstance","onMounted","index","syncRef","transform","ltr","v","direction","immediate","nextTick","Array","from","querySelectorAll","map","el","id","visible","text","textContent","isScrollingDown","previousScrollTop","scrollRoot","computed","getComputedStyle","overflowY","iobs","useIntersectionObserver","entries","scrollTop","_a","document","documentElement","forEach","entry","isIntersecting","node","newId","_b","reverse","find","_c","_d","nodes","foundParent","activeElement","parentDropdown","closest","getAttribute","includes","classList","add","querySelector","parentNav","previousSibling","contains","_e","_f","remove","_g","_h","_i","_j","_k","mobs","useMutationObserver","childList","stop","readonly","scrollIntoView","event","smooth","preventDefault","href","call","scrollTo","top","offsetTop","behavior","cleanup"],"mappings":"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"}