{"version":3,"file":"BFormTextarea.vue_vue_type_script_setup_true_lang-Dsl-lX8t.mjs","sources":["../src/composables/useTextareaResize.ts","../src/components/BFormTextarea/BFormTextarea.vue"],"sourcesContent":["import {useToNumber} from '@vueuse/core'\nimport type {Numberish} from '../types/CommonTypes'\nimport {\n  computed,\n  type CSSProperties,\n  type MaybeRefOrGetter,\n  nextTick,\n  onMounted,\n  readonly,\n  ref,\n  type ShallowRef,\n  toRef,\n} from 'vue'\nimport {isVisible} from '../utils/dom'\n\nexport const useTextareaResize = (\n  input: Readonly<ShallowRef<HTMLTextAreaElement | null>>,\n  props: MaybeRefOrGetter<{\n    rows: Numberish\n    maxRows: Numberish | undefined\n    noAutoShrink: boolean\n  }>\n) => {\n  const height = ref<number | null | string>(0)\n  const resolvedProps = readonly(toRef(props))\n  const maxRowsNumber = useToNumber(() => resolvedProps.value.maxRows || NaN, {\n    method: 'parseInt',\n    nanToZero: true,\n  })\n  const rowsNumber = useToNumber(() => resolvedProps.value.rows || NaN, {\n    method: 'parseInt',\n    nanToZero: true,\n  })\n  const computedMinRows = computed(() => Math.max(rowsNumber.value || 2, 2))\n  const computedMaxRows = computed(() => Math.max(computedMinRows.value, maxRowsNumber.value || 0))\n  const computedRows = computed(() =>\n    computedMinRows.value === computedMaxRows.value ? computedMinRows.value : null\n  )\n\n  const handleHeightChange = async () => {\n    // Element must be visible (not hidden) and in document\n    // Must be checked after above checks\n    if (!input.value || !isVisible(input.value)) {\n      height.value = null\n      return\n    }\n\n    // Get current computed styles\n    const computedStyle = getComputedStyle(input.value)\n    // Height of one line of text in px\n    const lineHeight = Number.parseFloat(computedStyle.lineHeight) || 1\n    // Calculate height of border and padding\n    const border =\n      (Number.parseFloat(computedStyle.borderTopWidth) || 0) +\n      (Number.parseFloat(computedStyle.borderBottomWidth) || 0)\n    const padding =\n      (Number.parseFloat(computedStyle.paddingTop) || 0) +\n      (Number.parseFloat(computedStyle.paddingBottom) || 0)\n    // Calculate offset\n    const offset = border + padding\n    // Minimum height for min rows (which must be 2 rows or greater for cross-browser support)\n    const minHeight = lineHeight * computedMinRows.value + offset\n\n    // Get the current style height (with `px` units)\n    const oldHeight = input.value.style.height || computedStyle.height\n    // Probe scrollHeight by temporarily changing the height to `auto`\n    height.value = 'auto'\n    await nextTick() // We need to wait for the dom to update. These cannot be batched in the same tick\n    const {scrollHeight} = input.value\n    // Place the original old height back on the element, just in case `computedProp`\n    // returns the same value as before\n    height.value = oldHeight\n    await nextTick() // We need to wait for the dom to update. These cannot be batched in the same tick\n\n    // Calculate content height in 'rows' (scrollHeight includes padding but not border)\n    const contentRows = Math.max((scrollHeight - padding) / lineHeight, 2)\n    // Calculate number of rows to display (limited within min/max rows)\n    const rows = Math.min(Math.max(contentRows, computedMinRows.value), computedMaxRows.value)\n    // Calculate the required height of the textarea including border and padding (in pixels)\n    const newHeight = Math.max(Math.ceil(rows * lineHeight + offset), minHeight)\n\n    // Computed height remains the larger of `oldHeight` and new `height`,\n    // when height is in `sticky` mode (prop `no-auto-shrink` is true)\n    if (\n      resolvedProps.value.noAutoShrink &&\n      (Number.parseFloat(oldHeight.toString()) || 0) > newHeight\n    ) {\n      height.value = oldHeight\n      return\n    }\n\n    // Return the new computed CSS height in px units\n    height.value = `${newHeight}px`\n  }\n\n  onMounted(handleHeightChange)\n\n  const computedStyles = computed<CSSProperties>(() => ({\n    resize: 'none',\n    height:\n      typeof height.value === 'string'\n        ? height.value\n        : height.value\n          ? `${height.value}px`\n          : undefined,\n  }))\n\n  return {\n    onInput: handleHeightChange,\n    computedStyles,\n    computedRows,\n  }\n}\n","<template>\n  <textarea\n    :id=\"computedId\"\n    ref=\"_input\"\n    :key=\"forceUpdateKey\"\n    :class=\"computedClasses\"\n    :name=\"props.name || undefined\"\n    :form=\"props.form || undefined\"\n    :value=\"modelValue ?? undefined\"\n    :disabled=\"props.disabled\"\n    :placeholder=\"props.placeholder\"\n    :required=\"props.required || undefined\"\n    :autocomplete=\"props.autocomplete || undefined\"\n    :readonly=\"props.readonly || props.plaintext\"\n    :aria-required=\"props.required || undefined\"\n    :aria-invalid=\"computedAriaInvalid\"\n    :rows=\"computedRows || 2\"\n    :style=\"computedStyles\"\n    :wrap=\"props.wrap || undefined\"\n    @input=\"\n      (e) => {\n        onInput(e)\n        handleHeightChange()\n      }\n    \"\n    @change=\"onChange\"\n    @blur=\"onBlur\"\n  />\n</template>\n\n<script setup lang=\"ts\">\nimport type {BFormTextareaProps} from '../../types/ComponentProps'\nimport {computed, type CSSProperties, useTemplateRef} from 'vue'\nimport {useDefaults} from '../../composables/useDefaults'\nimport {normalizeInput} from '../../utils/normalizeInput'\nimport {useFormInput} from '../../composables/useFormInput'\nimport {useTextareaResize} from '../../composables/useTextareaResize'\n\nconst _props = withDefaults(defineProps<Omit<BFormTextareaProps, 'modelValue'>>(), {\n  // CommonInputProps\n  ariaInvalid: undefined,\n  autocomplete: undefined,\n  autofocus: false,\n  debounce: 0,\n  debounceMaxWait: NaN,\n  disabled: false,\n  form: undefined,\n  formatter: undefined,\n  id: undefined,\n  lazyFormatter: false,\n  list: undefined,\n  modelValue: '',\n  name: undefined,\n  placeholder: undefined,\n  plaintext: false,\n  readonly: false,\n  required: false,\n  size: undefined,\n  state: undefined,\n  // End CommonInputProps\n  noResize: false,\n  noAutoShrink: false,\n  maxRows: undefined,\n  rows: 2,\n  wrap: 'soft',\n})\nconst props = useDefaults(_props, 'BFormTextarea')\n\nconst [modelValue, modelModifiers] = defineModel<\n  Exclude<BFormTextareaProps['modelValue'], undefined>,\n  'trim' | 'lazy' | 'number'\n>({\n  default: '',\n  set: (v) => normalizeInput(v, modelModifiers),\n})\n\nconst input = useTemplateRef<HTMLTextAreaElement>('_input')\n\nconst {\n  computedId,\n  forceUpdateKey,\n  computedAriaInvalid,\n  onInput,\n  stateClass,\n  onChange,\n  onBlur,\n  focus,\n  blur,\n} = useFormInput(props, input, modelValue, modelModifiers)\n\nconst computedClasses = computed(() => [\n  stateClass.value,\n  props.plaintext ? 'form-control-plaintext' : 'form-control',\n  {\n    [`form-control-${props.size}`]: !!props.size,\n  },\n])\n\nconst {\n  computedStyles: resizeStyles,\n  onInput: handleHeightChange,\n  computedRows,\n} = useTextareaResize(\n  input,\n  computed(() => ({\n    maxRows: props.maxRows,\n    rows: props.rows,\n    noAutoShrink: props.noAutoShrink,\n  }))\n)\n\nconst computedStyles = computed<CSSProperties>(() => ({\n  resize: props.noResize ? 'none' : undefined,\n  ...(props.maxRows || props.noAutoShrink ? resizeStyles.value : undefined),\n}))\n\ndefineExpose({\n  blur,\n  element: input,\n  focus,\n})\n</script>\n"],"names":["_useModel"],"mappings":"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"}