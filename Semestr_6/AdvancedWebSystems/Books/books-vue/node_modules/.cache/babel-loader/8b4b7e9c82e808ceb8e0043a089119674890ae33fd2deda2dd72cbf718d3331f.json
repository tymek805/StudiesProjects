{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nconst getActiveElement = (excludes = []) => {\n  const {\n    activeElement\n  } = document;\n  return activeElement && !(excludes == null ? void 0 : excludes.some(el => el === activeElement)) ? activeElement : null;\n};\nconst attemptFocus = (el, options = {}) => {\n  const isActiveElement = el2 => el2 === getActiveElement();\n  try {\n    el.focus(options);\n  } catch (e) {\n    console.error(e);\n  }\n  return isActiveElement(el);\n};\nconst isEmptySlot = el => ((el == null ? void 0 : el()) ?? []).length === 0;\nconst isVisible = el => {\n  if (el.getAttribute(\"display\") === \"none\") {\n    return false;\n  }\n  const bcr = el.getBoundingClientRect();\n  return !!(bcr && bcr.height > 0 && bcr.width > 0);\n};\nconst sortSlotElementsByPosition = (a, b) => {\n  if (typeof Node === \"undefined\" || !Node || !a || !b) return 0;\n  const position = a.compareDocumentPosition(b);\n  if (position & Node.DOCUMENT_POSITION_FOLLOWING) return -1;\n  if (position & Node.DOCUMENT_POSITION_PRECEDING) return 1;\n  return 0;\n};\nexport { isVisible as a, attemptFocus as b, getActiveElement as g, isEmptySlot as i, sortSlotElementsByPosition as s };","map":{"version":3,"names":["getActiveElement","excludes","activeElement","document","some","el","attemptFocus","options","isActiveElement","el2","focus","e","console","error","isEmptySlot","length","isVisible","getAttribute","bcr","getBoundingClientRect","height","width","sortSlotElementsByPosition","a","b","Node","position","compareDocumentPosition","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_PRECEDING"],"sources":["../src/utils/dom.ts"],"sourcesContent":["import type {Slot} from 'vue'\n\n// Get the currently active HTML element\nexport const getActiveElement = (excludes: readonly HTMLElement[] = []): Element | null => {\n  const {activeElement} = document\n  return activeElement && !excludes?.some((el) => el === activeElement) ? activeElement : null\n}\n\n/**\n * @deprecated only used in BFormGroup, which is not an SFC... Function could probably be replaced with pure Vue\n */\nexport const attemptFocus = (\n  el: Readonly<HTMLElement>,\n  options: Readonly<FocusOptions> = {}\n): boolean => {\n  const isActiveElement = (el: Readonly<HTMLElement>): boolean => el === getActiveElement()\n\n  try {\n    el.focus(options)\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.error(e)\n  }\n  return isActiveElement(el)\n}\n\nexport const isEmptySlot = (el: Slot | undefined): boolean => (el?.() ?? []).length === 0\n\n/**\n * @deprecated only used in BFormGroup, which is not an SFC... Function could probably be replaced with pure Vue\n */\nexport const isVisible = (el: Readonly<Element>): boolean => {\n  //if (!isElement(el) || !el.parentNode || !contains(DOCUMENT.body, el)) {\n  // Note this can fail for shadow dom elements since they\n  // are not a direct descendant of document.body\n  //return false\n  //}\n  if (el.getAttribute('display') === 'none') {\n    // We do this check to help with vue-test-utils when using v-show\n    return false\n  }\n  // All browsers support getBoundingClientRect(), except JSDOM as it returns all 0's for values :(\n  // So any tests that need isVisible will fail in JSDOM\n  // Except when we override the getBCR prototype in some tests\n  const bcr = el.getBoundingClientRect()\n  return !!(bcr && bcr.height > 0 && bcr.width > 0)\n}\n\nexport const getTransitionDelay = (element: Readonly<HTMLElement>) => {\n  const style = window.getComputedStyle(element)\n  // if multiple durations are defined, we take the first\n  const transitionDelay = style.transitionDelay.split(',')[0] || ''\n  const transitionDuration = style.transitionDuration.split(',')[0] || ''\n  const transitionDelayMs = Number(transitionDelay.slice(0, -1)) * 1000\n  const transitionDurationMs = Number(transitionDuration.slice(0, -1)) * 1000\n  return transitionDelayMs + transitionDurationMs\n}\n\nexport const sortSlotElementsByPosition = (\n  a: Readonly<HTMLElement> | null,\n  b: Readonly<HTMLElement> | null\n): number => {\n  if (typeof Node === 'undefined' || !Node || !a || !b) return 0\n  const position = a.compareDocumentPosition(b)\n  if (position & Node.DOCUMENT_POSITION_FOLLOWING) return -1\n  if (position & Node.DOCUMENT_POSITION_PRECEDING) return 1\n  return 0\n}\n"],"mappings":";;AAGO,MAAMA,gBAAA,GAAmBA,CAACC,QAAA,GAAmC,OAAuB;EACnF;IAACC;EAAA,IAAiBC,QAAA;EACjB,OAAAD,aAAA,IAAiB,EAACD,QAAA,oBAAAA,QAAA,CAAUG,IAAA,CAAMC,EAAA,IAAOA,EAAA,KAAOH,aAAA,KAAiBA,aAAA,GAAgB;AAC1F;AAKO,MAAMI,YAAA,GAAeA,CAC1BD,EAAA,EACAE,OAAA,GAAkC,OACtB;EACZ,MAAMC,eAAA,GAAmBC,GAAA,IAAuCA,GAAA,KAAOT,gBAAA,CAAiB;EAEpF;IACFK,EAAA,CAAGK,KAAA,CAAMH,OAAO;EAAA,SACTI,CAAA,EAAG;IAEVC,OAAA,CAAQC,KAAA,CAAMF,CAAC;EAAA;EAEjB,OAAOH,eAAA,CAAgBH,EAAE;AAC3B;AAEO,MAAMS,WAAA,GAAeT,EAAA,MAAmCA,EAAA,oBAAAA,EAAA,OAAU,IAAIU,MAAA,KAAW;AAK3E,MAAAC,SAAA,GAAaX,EAAA,IAAmC;EAM3D,IAAIA,EAAA,CAAGY,YAAA,CAAa,SAAS,MAAM,QAAQ;IAElC;EAAA;EAKH,MAAAC,GAAA,GAAMb,EAAA,CAAGc,qBAAA,CAAsB;EACrC,OAAO,CAAC,EAAED,GAAA,IAAOA,GAAA,CAAIE,MAAA,GAAS,KAAKF,GAAA,CAAIG,KAAA,GAAQ;AACjD;AAYa,MAAAC,0BAAA,GAA6BA,CACxCC,CAAA,EACAC,CAAA,KACW;EACP,WAAOC,IAAA,KAAS,eAAe,CAACA,IAAA,IAAQ,CAACF,CAAA,IAAK,CAACC,CAAA,EAAU;EACvD,MAAAE,QAAA,GAAWH,CAAA,CAAEI,uBAAA,CAAwBH,CAAC;EACxC,IAAAE,QAAA,GAAWD,IAAA,CAAKG,2BAAA,EAAoC;EACpD,IAAAF,QAAA,GAAWD,IAAA,CAAKI,2BAAA,EAAoC;EACjD;AACT","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}