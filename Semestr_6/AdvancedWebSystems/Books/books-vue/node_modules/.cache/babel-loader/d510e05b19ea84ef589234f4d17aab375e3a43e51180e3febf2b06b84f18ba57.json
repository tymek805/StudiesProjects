{"ast":null,"code":"import { ref, inject, computed, onMounted, onActivated, nextTick } from \"vue\";\nimport { u as useAriaInvalid } from \"./useAriaInvalid-BTUbGj3Y.mjs\";\nimport { u as useId } from \"./useId-BzCLXIGF.mjs\";\nimport { u as useFocus } from \"./index-cC189kCW.mjs\";\nimport { j as formGroupPluginKey } from \"./keys-D3gOZjD-.mjs\";\nimport { u as useStateClass } from \"./useStateClass-BGbSLWFN.mjs\";\nimport { u as useToNumber, r as useDebounceFn } from \"./index-CLgoGrAV.mjs\";\nconst normalizeInput = (v, modelModifiers) => {\n  if (v === null) return;\n  let update = v;\n  if (modelModifiers.number && typeof update === \"string\" && update !== \"\") {\n    const parsed = Number.parseFloat(update);\n    update = Number.isNaN(parsed) ? update : parsed;\n  }\n  return update;\n};\nconst useFormInput = (props, input, modelValue, modelModifiers) => {\n  var _a;\n  const forceUpdateKey = ref(0);\n  const computedId = useId(() => props.id, \"input\");\n  const debounceNumber = useToNumber(() => props.debounce ?? 0);\n  const debounceMaxWaitNumber = useToNumber(() => props.debounceMaxWait ?? NaN);\n  const formGroupData = (_a = inject(formGroupPluginKey, null)) == null ? void 0 : _a(computedId);\n  const computedState = computed(() => props.state !== void 0 ? props.state : (formGroupData == null ? void 0 : formGroupData.state.value) ?? null);\n  const computedAriaInvalid = useAriaInvalid(() => props.ariaInvalid, computedState);\n  const stateClass = useStateClass(computedState);\n  const internalUpdateModelValue = useDebounceFn(value => {\n    modelValue.value = value;\n  }, () => modelModifiers.lazy === true ? 0 : debounceNumber.value, {\n    maxWait: () => modelModifiers.lazy === true ? NaN : debounceMaxWaitNumber.value\n  });\n  const updateModelValue = (value, force = false) => {\n    if (modelModifiers.lazy === true && force === false) return;\n    internalUpdateModelValue(value);\n  };\n  const {\n    focused\n  } = useFocus(input, {\n    initialValue: props.autofocus\n  });\n  const _formatValue = (value, evt, force = false) => {\n    if (props.formatter !== void 0 && (!props.lazyFormatter || force)) {\n      return props.formatter(value, evt);\n    }\n    return value;\n  };\n  onMounted(() => {\n    var _a2;\n    if (input.value) {\n      input.value.value = ((_a2 = modelValue.value) == null ? void 0 : _a2.toString()) ?? \"\";\n    }\n  });\n  onActivated(() => {\n    nextTick(() => {\n      if (props.autofocus) {\n        focused.value = true;\n      }\n    });\n  });\n  const onInput = evt => {\n    const {\n      value\n    } = evt.target;\n    const formattedValue = _formatValue(value, evt);\n    if (evt.defaultPrevented) {\n      evt.preventDefault();\n      return;\n    }\n    const nextModel = formattedValue;\n    updateModelValue(nextModel);\n  };\n  const onChange = evt => {\n    const {\n      value\n    } = evt.target;\n    const formattedValue = _formatValue(value, evt);\n    if (evt.defaultPrevented) {\n      evt.preventDefault();\n      return;\n    }\n    const nextModel = formattedValue;\n    if (modelValue.value !== nextModel) {\n      updateModelValue(formattedValue, true);\n    }\n  };\n  const onBlur = evt => {\n    if (!modelModifiers.lazy && !props.lazyFormatter && !modelModifiers.trim) return;\n    const {\n      value\n    } = evt.target;\n    const formattedValue = _formatValue(value, evt, true);\n    const nextModel = modelModifiers.trim ? formattedValue.trim() : formattedValue;\n    const needsForceUpdate = nextModel.length !== formattedValue.length;\n    if (modelValue.value !== nextModel) {\n      updateModelValue(formattedValue, true);\n    }\n    if (modelModifiers.trim && needsForceUpdate) {\n      forceUpdateKey.value = forceUpdateKey.value + 1;\n    }\n  };\n  const focus = () => {\n    if (!props.disabled) {\n      focused.value = true;\n    }\n  };\n  const blur = () => {\n    if (!props.disabled) {\n      focused.value = false;\n    }\n  };\n  return {\n    input,\n    computedId,\n    computedAriaInvalid,\n    onInput,\n    onChange,\n    onBlur,\n    focus,\n    blur,\n    forceUpdateKey,\n    stateClass\n  };\n};\nexport { normalizeInput as n, useFormInput as u };","map":{"version":3,"names":["normalizeInput","v","modelModifiers","update","number","parsed","Number","parseFloat","isNaN","useFormInput","props","input","modelValue","forceUpdateKey","ref","computedId","useId","id","debounceNumber","useToNumber","debounce","debounceMaxWaitNumber","debounceMaxWait","NaN","formGroupData","_a","inject","formGroupPluginKey","computedState","computed","state","value","computedAriaInvalid","useAriaInvalid","ariaInvalid","stateClass","useStateClass","internalUpdateModelValue","useDebounceFn","lazy","maxWait","updateModelValue","force","focused","useFocus","initialValue","autofocus","_formatValue","evt","formatter","lazyFormatter","onMounted","_a2","toString","onActivated","nextTick","onInput","target","formattedValue","defaultPrevented","preventDefault","nextModel","onChange","onBlur","trim","needsForceUpdate","length","focus","disabled","blur"],"sources":["../src/utils/normalizeInput.ts","../src/composables/useFormInput.ts"],"sourcesContent":["import type {Numberish} from '../types/CommonTypes'\n\nexport const normalizeInput = (\n  v: Numberish | null,\n  modelModifiers: Record<'number' | 'lazy' | 'trim', true | undefined>\n) => {\n  if (v === null) return\n  let update = v\n  if (modelModifiers.number && typeof update === 'string' && update !== '') {\n    const parsed = Number.parseFloat(update)\n    update = Number.isNaN(parsed) ? update : parsed\n  }\n  return update\n}\n","import type {Numberish} from '../types/CommonTypes'\nimport {\n  computed,\n  inject,\n  nextTick,\n  onActivated,\n  onMounted,\n  ref,\n  type Ref,\n  type ShallowRef,\n} from 'vue'\nimport {useAriaInvalid} from './useAriaInvalid'\nimport {useId} from './useId'\nimport {useDebounceFn, useFocus, useToNumber} from '@vueuse/core'\nimport type {CommonInputProps} from '../types/FormCommonInputProps'\nimport {formGroupPluginKey} from '../utils/keys'\nimport {useStateClass} from './useStateClass'\n\nexport const useFormInput = (\n  props: Readonly<CommonInputProps>,\n  input:\n    | Readonly<ShallowRef<HTMLInputElement | null>>\n    | Readonly<ShallowRef<HTMLTextAreaElement | null>>,\n  modelValue: Ref<Numberish | null>,\n  modelModifiers: Record<'number' | 'lazy' | 'trim', true | undefined>\n) => {\n  const forceUpdateKey = ref(0)\n\n  const computedId = useId(() => props.id, 'input')\n  const debounceNumber = useToNumber(() => props.debounce ?? 0)\n  const debounceMaxWaitNumber = useToNumber(() => props.debounceMaxWait ?? NaN)\n\n  // This automatically adds the appropriate \"for\" attribute to a BFormGroup label\n  const formGroupData = inject(formGroupPluginKey, null)?.(computedId)\n  const computedState = computed(() =>\n    props.state !== undefined ? props.state : (formGroupData?.state.value ?? null)\n  )\n  const computedAriaInvalid = useAriaInvalid(() => props.ariaInvalid, computedState)\n  const stateClass = useStateClass(computedState)\n\n  const internalUpdateModelValue = useDebounceFn(\n    (value: Numberish) => {\n      modelValue.value = value\n    },\n    () => (modelModifiers.lazy === true ? 0 : debounceNumber.value),\n    {maxWait: () => (modelModifiers.lazy === true ? NaN : debounceMaxWaitNumber.value)}\n  )\n\n  const updateModelValue = (value: Numberish, force = false) => {\n    if (modelModifiers.lazy === true && force === false) return\n    internalUpdateModelValue(value)\n  }\n\n  const {focused} = useFocus(input, {\n    initialValue: props.autofocus,\n  })\n\n  const _formatValue = (value: string, evt: Readonly<Event>, force = false) => {\n    if (props.formatter !== undefined && (!props.lazyFormatter || force)) {\n      return props.formatter(value, evt)\n    }\n    return value\n  }\n  onMounted(() => {\n    if (input.value) {\n      input.value.value = modelValue.value?.toString() ?? ''\n    }\n  })\n\n  onActivated(() => {\n    nextTick(() => {\n      if (props.autofocus) {\n        focused.value = true\n      }\n    })\n  })\n\n  const onInput = (evt: Readonly<Event>) => {\n    const {value} = evt.target as HTMLInputElement\n    const formattedValue = _formatValue(value, evt)\n    if (evt.defaultPrevented) {\n      evt.preventDefault()\n      return\n    }\n\n    const nextModel = formattedValue\n\n    updateModelValue(nextModel)\n  }\n\n  const onChange = (evt: Readonly<Event>) => {\n    const {value} = evt.target as HTMLInputElement\n    const formattedValue = _formatValue(value, evt)\n    if (evt.defaultPrevented) {\n      evt.preventDefault()\n      return\n    }\n\n    const nextModel = formattedValue\n    if (modelValue.value !== nextModel) {\n      updateModelValue(formattedValue, true)\n    }\n  }\n\n  const onBlur = (evt: Readonly<FocusEvent>) => {\n    if (!modelModifiers.lazy && !props.lazyFormatter && !modelModifiers.trim) return\n\n    const {value} = evt.target as HTMLInputElement\n    const formattedValue = _formatValue(value, evt, true)\n\n    const nextModel = modelModifiers.trim ? formattedValue.trim() : formattedValue\n    const needsForceUpdate = nextModel.length !== formattedValue.length\n    if (modelValue.value !== nextModel) {\n      updateModelValue(formattedValue, true)\n    }\n    if (modelModifiers.trim && needsForceUpdate) {\n      // The value is trimmed but there would still exist some white space\n      // So, force update the value. You need to bind this to :key on the input element\n      forceUpdateKey.value = forceUpdateKey.value + 1\n    }\n  }\n\n  const focus = () => {\n    if (!props.disabled) {\n      focused.value = true\n    }\n  }\n\n  const blur = () => {\n    if (!props.disabled) {\n      focused.value = false\n    }\n  }\n\n  return {\n    input,\n    computedId,\n    computedAriaInvalid,\n    onInput,\n    onChange,\n    onBlur,\n    focus,\n    blur,\n    forceUpdateKey,\n    stateClass,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}