{"ast":null,"code":"import { ref, readonly, toRef, computed, onMounted, nextTick, defineComponent, mergeModels, useModel, useTemplateRef, createElementBlock, openBlock, unref, normalizeStyle, normalizeClass } from \"vue\";\nimport { u as useDefaults } from \"./useDefaults-DANje4tM.mjs\";\nimport { n as normalizeInput, u as useFormInput } from \"./useFormInput-BA20uvAP.mjs\";\nimport { a as isVisible } from \"./dom-BK2w00Ec.mjs\";\nimport { u as useToNumber } from \"./index-CLgoGrAV.mjs\";\nconst useTextareaResize = (input, props) => {\n  const height = ref(0);\n  const resolvedProps = readonly(toRef(props));\n  const maxRowsNumber = useToNumber(() => resolvedProps.value.maxRows || NaN, {\n    method: \"parseInt\",\n    nanToZero: true\n  });\n  const rowsNumber = useToNumber(() => resolvedProps.value.rows || NaN, {\n    method: \"parseInt\",\n    nanToZero: true\n  });\n  const computedMinRows = computed(() => Math.max(rowsNumber.value || 2, 2));\n  const computedMaxRows = computed(() => Math.max(computedMinRows.value, maxRowsNumber.value || 0));\n  const computedRows = computed(() => computedMinRows.value === computedMaxRows.value ? computedMinRows.value : null);\n  const handleHeightChange = async () => {\n    if (!input.value || !isVisible(input.value)) {\n      height.value = null;\n      return;\n    }\n    const computedStyle = getComputedStyle(input.value);\n    const lineHeight = Number.parseFloat(computedStyle.lineHeight) || 1;\n    const border = (Number.parseFloat(computedStyle.borderTopWidth) || 0) + (Number.parseFloat(computedStyle.borderBottomWidth) || 0);\n    const padding = (Number.parseFloat(computedStyle.paddingTop) || 0) + (Number.parseFloat(computedStyle.paddingBottom) || 0);\n    const offset = border + padding;\n    const minHeight = lineHeight * computedMinRows.value + offset;\n    const oldHeight = input.value.style.height || computedStyle.height;\n    height.value = \"auto\";\n    await nextTick();\n    const {\n      scrollHeight\n    } = input.value;\n    height.value = oldHeight;\n    await nextTick();\n    const contentRows = Math.max((scrollHeight - padding) / lineHeight, 2);\n    const rows = Math.min(Math.max(contentRows, computedMinRows.value), computedMaxRows.value);\n    const newHeight = Math.max(Math.ceil(rows * lineHeight + offset), minHeight);\n    if (resolvedProps.value.noAutoShrink && (Number.parseFloat(oldHeight.toString()) || 0) > newHeight) {\n      height.value = oldHeight;\n      return;\n    }\n    height.value = `${newHeight}px`;\n  };\n  onMounted(handleHeightChange);\n  const computedStyles = computed(() => ({\n    resize: \"none\",\n    height: typeof height.value === \"string\" ? height.value : height.value ? `${height.value}px` : void 0\n  }));\n  return {\n    onInput: handleHeightChange,\n    computedStyles,\n    computedRows\n  };\n};\nconst _hoisted_1 = [\"id\", \"name\", \"form\", \"value\", \"disabled\", \"placeholder\", \"required\", \"autocomplete\", \"readonly\", \"aria-required\", \"aria-invalid\", \"rows\", \"wrap\"];\nconst _sfc_main = /* @__PURE__ */defineComponent({\n  __name: \"BFormTextarea\",\n  props: /* @__PURE__ */mergeModels({\n    noResize: {\n      type: Boolean,\n      default: false\n    },\n    rows: {\n      default: 2\n    },\n    wrap: {\n      default: \"soft\"\n    },\n    noAutoShrink: {\n      type: Boolean,\n      default: false\n    },\n    maxRows: {\n      default: void 0\n    },\n    ariaInvalid: {\n      type: [Boolean, String],\n      default: void 0\n    },\n    autocomplete: {\n      default: void 0\n    },\n    autofocus: {\n      type: Boolean,\n      default: false\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    },\n    form: {\n      default: void 0\n    },\n    formatter: {\n      type: Function,\n      default: void 0\n    },\n    id: {\n      default: void 0\n    },\n    lazyFormatter: {\n      type: Boolean,\n      default: false\n    },\n    list: {\n      default: void 0\n    },\n    name: {\n      default: void 0\n    },\n    placeholder: {\n      default: void 0\n    },\n    plaintext: {\n      type: Boolean,\n      default: false\n    },\n    readonly: {\n      type: Boolean,\n      default: false\n    },\n    required: {\n      type: Boolean,\n      default: false\n    },\n    size: {\n      default: void 0\n    },\n    state: {\n      type: [Boolean, null],\n      default: void 0\n    },\n    debounce: {\n      default: 0\n    },\n    debounceMaxWait: {\n      default: NaN\n    }\n  }, {\n    \"modelValue\": {\n      default: \"\"\n    },\n    \"modelModifiers\": {}\n  }),\n  emits: [\"update:modelValue\"],\n  setup(__props, {\n    expose: __expose\n  }) {\n    const _props = __props;\n    const props = useDefaults(_props, \"BFormTextarea\");\n    const [modelValue, modelModifiers] = useModel(__props, \"modelValue\", {\n      set: v => normalizeInput(v, modelModifiers)\n    });\n    const input = useTemplateRef(\"_input\");\n    const {\n      computedId,\n      forceUpdateKey,\n      computedAriaInvalid,\n      onInput,\n      stateClass,\n      onChange,\n      onBlur,\n      focus,\n      blur\n    } = useFormInput(props, input, modelValue, modelModifiers);\n    const computedClasses = computed(() => [stateClass.value, props.plaintext ? \"form-control-plaintext\" : \"form-control\", {\n      [`form-control-${props.size}`]: !!props.size\n    }]);\n    const {\n      computedStyles: resizeStyles,\n      onInput: handleHeightChange,\n      computedRows\n    } = useTextareaResize(input, computed(() => ({\n      maxRows: props.maxRows,\n      rows: props.rows,\n      noAutoShrink: props.noAutoShrink\n    })));\n    const computedStyles = computed(() => ({\n      resize: props.noResize ? \"none\" : void 0,\n      ...(props.maxRows || props.noAutoShrink ? resizeStyles.value : void 0)\n    }));\n    __expose({\n      blur,\n      element: input,\n      focus\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"textarea\", {\n        id: unref(computedId),\n        ref: \"_input\",\n        key: unref(forceUpdateKey),\n        class: normalizeClass(computedClasses.value),\n        name: unref(props).name || void 0,\n        form: unref(props).form || void 0,\n        value: unref(modelValue) ?? void 0,\n        disabled: unref(props).disabled,\n        placeholder: unref(props).placeholder,\n        required: unref(props).required || void 0,\n        autocomplete: unref(props).autocomplete || void 0,\n        readonly: unref(props).readonly || unref(props).plaintext,\n        \"aria-required\": unref(props).required || void 0,\n        \"aria-invalid\": unref(computedAriaInvalid),\n        rows: unref(computedRows) || 2,\n        style: normalizeStyle(computedStyles.value),\n        wrap: unref(props).wrap || void 0,\n        onInput: _cache[0] || (_cache[0] = e => {\n          unref(onInput)(e);\n          unref(handleHeightChange)();\n        }),\n        onChange: _cache[1] || (_cache[1] =\n        //@ts-ignore\n        (...args) => unref(onChange) && unref(onChange)(...args)),\n        onBlur: _cache[2] || (_cache[2] =\n        //@ts-ignore\n        (...args) => unref(onBlur) && unref(onBlur)(...args))\n      }, null, 46, _hoisted_1);\n    };\n  }\n});\nexport { _sfc_main as _ };","map":{"version":3,"names":["useTextareaResize","input","props","height","ref","resolvedProps","readonly","toRef","maxRowsNumber","useToNumber","value","maxRows","NaN","method","nanToZero","rowsNumber","rows","computedMinRows","computed","Math","max","computedMaxRows","computedRows","handleHeightChange","isVisible","computedStyle","getComputedStyle","lineHeight","Number","parseFloat","border","borderTopWidth","borderBottomWidth","padding","paddingTop","paddingBottom","offset","minHeight","oldHeight","style","nextTick","scrollHeight","contentRows","min","newHeight","ceil","noAutoShrink","toString","onMounted","computedStyles","resize","onInput","_props","__props","useDefaults","modelValue","modelModifiers","useModel","set","v","normalizeInput","useTemplateRef","computedId","forceUpdateKey","computedAriaInvalid","stateClass","onChange","onBlur","focus","blur","useFormInput","computedClasses","plaintext","size","resizeStyles","noResize","__expose","element"],"sources":["../src/composables/useTextareaResize.ts","../src/components/BFormTextarea/BFormTextarea.vue"],"sourcesContent":["import {useToNumber} from '@vueuse/core'\nimport type {Numberish} from '../types/CommonTypes'\nimport {\n  computed,\n  type CSSProperties,\n  type MaybeRefOrGetter,\n  nextTick,\n  onMounted,\n  readonly,\n  ref,\n  type ShallowRef,\n  toRef,\n} from 'vue'\nimport {isVisible} from '../utils/dom'\n\nexport const useTextareaResize = (\n  input: Readonly<ShallowRef<HTMLTextAreaElement | null>>,\n  props: MaybeRefOrGetter<{\n    rows: Numberish\n    maxRows: Numberish | undefined\n    noAutoShrink: boolean\n  }>\n) => {\n  const height = ref<number | null | string>(0)\n  const resolvedProps = readonly(toRef(props))\n  const maxRowsNumber = useToNumber(() => resolvedProps.value.maxRows || NaN, {\n    method: 'parseInt',\n    nanToZero: true,\n  })\n  const rowsNumber = useToNumber(() => resolvedProps.value.rows || NaN, {\n    method: 'parseInt',\n    nanToZero: true,\n  })\n  const computedMinRows = computed(() => Math.max(rowsNumber.value || 2, 2))\n  const computedMaxRows = computed(() => Math.max(computedMinRows.value, maxRowsNumber.value || 0))\n  const computedRows = computed(() =>\n    computedMinRows.value === computedMaxRows.value ? computedMinRows.value : null\n  )\n\n  const handleHeightChange = async () => {\n    // Element must be visible (not hidden) and in document\n    // Must be checked after above checks\n    if (!input.value || !isVisible(input.value)) {\n      height.value = null\n      return\n    }\n\n    // Get current computed styles\n    const computedStyle = getComputedStyle(input.value)\n    // Height of one line of text in px\n    const lineHeight = Number.parseFloat(computedStyle.lineHeight) || 1\n    // Calculate height of border and padding\n    const border =\n      (Number.parseFloat(computedStyle.borderTopWidth) || 0) +\n      (Number.parseFloat(computedStyle.borderBottomWidth) || 0)\n    const padding =\n      (Number.parseFloat(computedStyle.paddingTop) || 0) +\n      (Number.parseFloat(computedStyle.paddingBottom) || 0)\n    // Calculate offset\n    const offset = border + padding\n    // Minimum height for min rows (which must be 2 rows or greater for cross-browser support)\n    const minHeight = lineHeight * computedMinRows.value + offset\n\n    // Get the current style height (with `px` units)\n    const oldHeight = input.value.style.height || computedStyle.height\n    // Probe scrollHeight by temporarily changing the height to `auto`\n    height.value = 'auto'\n    await nextTick() // We need to wait for the dom to update. These cannot be batched in the same tick\n    const {scrollHeight} = input.value\n    // Place the original old height back on the element, just in case `computedProp`\n    // returns the same value as before\n    height.value = oldHeight\n    await nextTick() // We need to wait for the dom to update. These cannot be batched in the same tick\n\n    // Calculate content height in 'rows' (scrollHeight includes padding but not border)\n    const contentRows = Math.max((scrollHeight - padding) / lineHeight, 2)\n    // Calculate number of rows to display (limited within min/max rows)\n    const rows = Math.min(Math.max(contentRows, computedMinRows.value), computedMaxRows.value)\n    // Calculate the required height of the textarea including border and padding (in pixels)\n    const newHeight = Math.max(Math.ceil(rows * lineHeight + offset), minHeight)\n\n    // Computed height remains the larger of `oldHeight` and new `height`,\n    // when height is in `sticky` mode (prop `no-auto-shrink` is true)\n    if (\n      resolvedProps.value.noAutoShrink &&\n      (Number.parseFloat(oldHeight.toString()) || 0) > newHeight\n    ) {\n      height.value = oldHeight\n      return\n    }\n\n    // Return the new computed CSS height in px units\n    height.value = `${newHeight}px`\n  }\n\n  onMounted(handleHeightChange)\n\n  const computedStyles = computed<CSSProperties>(() => ({\n    resize: 'none',\n    height:\n      typeof height.value === 'string'\n        ? height.value\n        : height.value\n          ? `${height.value}px`\n          : undefined,\n  }))\n\n  return {\n    onInput: handleHeightChange,\n    computedStyles,\n    computedRows,\n  }\n}\n","<template>\n  <textarea\n    :id=\"computedId\"\n    ref=\"_input\"\n    :key=\"forceUpdateKey\"\n    :class=\"computedClasses\"\n    :name=\"props.name || undefined\"\n    :form=\"props.form || undefined\"\n    :value=\"modelValue ?? undefined\"\n    :disabled=\"props.disabled\"\n    :placeholder=\"props.placeholder\"\n    :required=\"props.required || undefined\"\n    :autocomplete=\"props.autocomplete || undefined\"\n    :readonly=\"props.readonly || props.plaintext\"\n    :aria-required=\"props.required || undefined\"\n    :aria-invalid=\"computedAriaInvalid\"\n    :rows=\"computedRows || 2\"\n    :style=\"computedStyles\"\n    :wrap=\"props.wrap || undefined\"\n    @input=\"\n      (e) => {\n        onInput(e)\n        handleHeightChange()\n      }\n    \"\n    @change=\"onChange\"\n    @blur=\"onBlur\"\n  />\n</template>\n\n<script setup lang=\"ts\">\nimport type {BFormTextareaProps} from '../../types/ComponentProps'\nimport {computed, type CSSProperties, useTemplateRef} from 'vue'\nimport {useDefaults} from '../../composables/useDefaults'\nimport {normalizeInput} from '../../utils/normalizeInput'\nimport {useFormInput} from '../../composables/useFormInput'\nimport {useTextareaResize} from '../../composables/useTextareaResize'\n\nconst _props = withDefaults(defineProps<Omit<BFormTextareaProps, 'modelValue'>>(), {\n  // CommonInputProps\n  ariaInvalid: undefined,\n  autocomplete: undefined,\n  autofocus: false,\n  debounce: 0,\n  debounceMaxWait: NaN,\n  disabled: false,\n  form: undefined,\n  formatter: undefined,\n  id: undefined,\n  lazyFormatter: false,\n  list: undefined,\n  modelValue: '',\n  name: undefined,\n  placeholder: undefined,\n  plaintext: false,\n  readonly: false,\n  required: false,\n  size: undefined,\n  state: undefined,\n  // End CommonInputProps\n  noResize: false,\n  noAutoShrink: false,\n  maxRows: undefined,\n  rows: 2,\n  wrap: 'soft',\n})\nconst props = useDefaults(_props, 'BFormTextarea')\n\nconst [modelValue, modelModifiers] = defineModel<\n  Exclude<BFormTextareaProps['modelValue'], undefined>,\n  'trim' | 'lazy' | 'number'\n>({\n  default: '',\n  set: (v) => normalizeInput(v, modelModifiers),\n})\n\nconst input = useTemplateRef<HTMLTextAreaElement>('_input')\n\nconst {\n  computedId,\n  forceUpdateKey,\n  computedAriaInvalid,\n  onInput,\n  stateClass,\n  onChange,\n  onBlur,\n  focus,\n  blur,\n} = useFormInput(props, input, modelValue, modelModifiers)\n\nconst computedClasses = computed(() => [\n  stateClass.value,\n  props.plaintext ? 'form-control-plaintext' : 'form-control',\n  {\n    [`form-control-${props.size}`]: !!props.size,\n  },\n])\n\nconst {\n  computedStyles: resizeStyles,\n  onInput: handleHeightChange,\n  computedRows,\n} = useTextareaResize(\n  input,\n  computed(() => ({\n    maxRows: props.maxRows,\n    rows: props.rows,\n    noAutoShrink: props.noAutoShrink,\n  }))\n)\n\nconst computedStyles = computed<CSSProperties>(() => ({\n  resize: props.noResize ? 'none' : undefined,\n  ...(props.maxRows || props.noAutoShrink ? resizeStyles.value : undefined),\n}))\n\ndefineExpose({\n  blur,\n  element: input,\n  focus,\n})\n</script>\n"],"mappings":";;;;;AAea,MAAAA,iBAAA,GAAoBA,CAC/BC,KAAA,EACAC,KAAA,KAKG;EACG,MAAAC,MAAA,GAASC,GAAA,CAA4B,CAAC;EAC5C,MAAMC,aAAA,GAAgBC,QAAA,CAASC,KAAA,CAAML,KAAK,CAAC;EAC3C,MAAMM,aAAA,GAAgBC,WAAA,CAAY,MAAMJ,aAAA,CAAcK,KAAA,CAAMC,OAAA,IAAWC,GAAA,EAAK;IAC1EC,MAAA,EAAQ;IACRC,SAAA,EAAW;EAAA,CACZ;EACD,MAAMC,UAAA,GAAaN,WAAA,CAAY,MAAMJ,aAAA,CAAcK,KAAA,CAAMM,IAAA,IAAQJ,GAAA,EAAK;IACpEC,MAAA,EAAQ;IACRC,SAAA,EAAW;EAAA,CACZ;EACK,MAAAG,eAAA,GAAkBC,QAAA,CAAS,MAAMC,IAAA,CAAKC,GAAA,CAAIL,UAAA,CAAWL,KAAA,IAAS,GAAG,CAAC,CAAC;EACnE,MAAAW,eAAA,GAAkBH,QAAA,CAAS,MAAMC,IAAA,CAAKC,GAAA,CAAIH,eAAA,CAAgBP,KAAA,EAAOF,aAAA,CAAcE,KAAA,IAAS,CAAC,CAAC;EAChG,MAAMY,YAAA,GAAeJ,QAAA,CAAS,MAC5BD,eAAA,CAAgBP,KAAA,KAAUW,eAAA,CAAgBX,KAAA,GAAQO,eAAA,CAAgBP,KAAA,GAAQ,IAC5E;EAEA,MAAMa,kBAAA,GAAqB,MAAAA,CAAA,KAAY;IAGrC,IAAI,CAACtB,KAAA,CAAMS,KAAA,IAAS,CAACc,SAAA,CAAUvB,KAAA,CAAMS,KAAK,GAAG;MAC3CP,MAAA,CAAOO,KAAA,GAAQ;MACf;IAAA;IAII,MAAAe,aAAA,GAAgBC,gBAAA,CAAiBzB,KAAA,CAAMS,KAAK;IAElD,MAAMiB,UAAA,GAAaC,MAAA,CAAOC,UAAA,CAAWJ,aAAA,CAAcE,UAAU,KAAK;IAE5D,MAAAG,MAAA,IACHF,MAAA,CAAOC,UAAA,CAAWJ,aAAA,CAAcM,cAAc,KAAK,MACnDH,MAAA,CAAOC,UAAA,CAAWJ,aAAA,CAAcO,iBAAiB,KAAK;IACnD,MAAAC,OAAA,IACHL,MAAA,CAAOC,UAAA,CAAWJ,aAAA,CAAcS,UAAU,KAAK,MAC/CN,MAAA,CAAOC,UAAA,CAAWJ,aAAA,CAAcU,aAAa,KAAK;IAErD,MAAMC,MAAA,GAASN,MAAA,GAASG,OAAA;IAElB,MAAAI,SAAA,GAAYV,UAAA,GAAaV,eAAA,CAAgBP,KAAA,GAAQ0B,MAAA;IAGvD,MAAME,SAAA,GAAYrC,KAAA,CAAMS,KAAA,CAAM6B,KAAA,CAAMpC,MAAA,IAAUsB,aAAA,CAActB,MAAA;IAE5DA,MAAA,CAAOO,KAAA,GAAQ;IACf,MAAM8B,QAAA,CAAS;IACT;MAACC;IAAA,IAAgBxC,KAAA,CAAMS,KAAA;IAG7BP,MAAA,CAAOO,KAAA,GAAQ4B,SAAA;IACf,MAAME,QAAA,CAAS;IAGf,MAAME,WAAA,GAAcvB,IAAA,CAAKC,GAAA,EAAKqB,YAAA,GAAeR,OAAA,IAAWN,UAAA,EAAY,CAAC;IAE/D,MAAAX,IAAA,GAAOG,IAAA,CAAKwB,GAAA,CAAIxB,IAAA,CAAKC,GAAA,CAAIsB,WAAA,EAAazB,eAAA,CAAgBP,KAAK,GAAGW,eAAA,CAAgBX,KAAK;IAEnF,MAAAkC,SAAA,GAAYzB,IAAA,CAAKC,GAAA,CAAID,IAAA,CAAK0B,IAAA,CAAK7B,IAAA,GAAOW,UAAA,GAAaS,MAAM,GAAGC,SAAS;IAKzE,IAAAhC,aAAA,CAAcK,KAAA,CAAMoC,YAAA,KACnBlB,MAAA,CAAOC,UAAA,CAAWS,SAAA,CAAUS,QAAA,CAAS,CAAC,KAAK,KAAKH,SAAA,EACjD;MACAzC,MAAA,CAAOO,KAAA,GAAQ4B,SAAA;MACf;IAAA;IAIKnC,MAAA,CAAAO,KAAA,GAAQ,GAAGkC,SAAS;EAC7B;EAEAI,SAAA,CAAUzB,kBAAkB;EAEtB,MAAA0B,cAAA,GAAiB/B,QAAA,CAAwB,OAAO;IACpDgC,MAAA,EAAQ;IACR/C,MAAA,EACE,OAAOA,MAAA,CAAOO,KAAA,KAAU,WACpBP,MAAA,CAAOO,KAAA,GACPP,MAAA,CAAOO,KAAA,GACL,GAAGP,MAAA,CAAOO,KAAK,OACf;EAAA,EACR;EAEK;IACLyC,OAAA,EAAS5B,kBAAA;IACT0B,cAAA;IACA3B;EACF;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IC1EA,MAAM8B,MAAA,GAASC,OAAA;IA4BT,MAAAnD,KAAA,GAAQoD,WAAA,CAAYF,MAAA,EAAQ,eAAe;IAEjD,MAAM,CAACG,UAAA,EAAYC,cAAc,IAAIC,QAAA,CAGnCJ,OAAA;MAEAK,GAAA,EAAMC,CAAA,IAAMC,cAAA,CAAeD,CAAA,EAAGH,cAAc;IAAA,CAC7C;IAEK,MAAAvD,KAAA,GAAQ4D,cAAA,CAAoC,QAAQ;IAEpD;MACJC,UAAA;MACAC,cAAA;MACAC,mBAAA;MACAb,OAAA;MACAc,UAAA;MACAC,QAAA;MACAC,MAAA;MACAC,KAAA;MACAC;IACE,IAAAC,YAAA,CAAapE,KAAA,EAAOD,KAAA,EAAOsD,UAAA,EAAYC,cAAc;IAEnD,MAAAe,eAAA,GAAkBrD,QAAA,CAAS,MAAM,CACrC+C,UAAA,CAAWvD,KAAA,EACXR,KAAA,CAAMsE,SAAA,GAAY,2BAA2B,gBAC7C;MACE,CAAC,gBAAgBtE,KAAA,CAAMuE,IAAI,EAAE,GAAG,CAAC,CAACvE,KAAA,CAAMuE;IAAA,EAE3C;IAEK;MACJxB,cAAA,EAAgByB,YAAA;MAChBvB,OAAA,EAAS5B,kBAAA;MACTD;IAAA,IACEtB,iBAAA,CACFC,KAAA,EACAiB,QAAA,CAAS,OAAO;MACdP,OAAA,EAAST,KAAA,CAAMS,OAAA;MACfK,IAAA,EAAMd,KAAA,CAAMc,IAAA;MACZ8B,YAAA,EAAc5C,KAAA,CAAM4C;IAAA,EACpB,CACJ;IAEM,MAAAG,cAAA,GAAiB/B,QAAA,CAAwB,OAAO;MACpDgC,MAAA,EAAQhD,KAAA,CAAMyE,QAAA,GAAW,SAAS;MAClC,IAAIzE,KAAA,CAAMS,OAAA,IAAWT,KAAA,CAAM4C,YAAA,GAAe4B,YAAA,CAAahE,KAAA,GAAQ;IAAA,EAC/D;IAEWkE,QAAA;MACXP,IAAA;MACAQ,OAAA,EAAS5E,KAAA;MACTmE;IAAA,CACD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}