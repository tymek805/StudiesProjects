{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport { g as getSSRHandler, e as unrefElement } from \"./index-cC189kCW.mjs\";\nimport { getCurrentInstance, watch, computed, toValue, inject } from \"vue\";\nimport { a as modalManagerPluginKey } from \"./keys-D3gOZjD-.mjs\";\nimport { d as tryOnScopeDispose } from \"./index-CLgoGrAV.mjs\";\nconst modalOpenClassName = \"modal-open\";\nconst useSharedModalStack = () => {\n  const modalManagerPlugin = inject(modalManagerPluginKey);\n  const dispose = modal => {\n    modalManagerPlugin == null ? void 0 : modalManagerPlugin.removeStack(modal);\n    modalManagerPlugin == null ? void 0 : modalManagerPlugin.removeRegistry(modal);\n  };\n  const updateHTMLAttrs = getSSRHandler(\"updateHTMLAttrs\", (selector, attribute, value) => {\n    const el = typeof selector === \"string\" ? window == null ? void 0 : window.document.querySelector(selector) : unrefElement(selector);\n    if (!el) return;\n    if (attribute === \"class\") {\n      el.classList.toggle(modalOpenClassName, value === modalOpenClassName);\n    } else {\n      el.setAttribute(attribute, value);\n    }\n  });\n  tryOnScopeDispose(() => {\n    updateHTMLAttrs(\"body\", \"class\", \"\");\n  });\n  watch(() => modalManagerPlugin == null ? void 0 : modalManagerPlugin.countStack.value, newValue => {\n    if (newValue === void 0) return;\n    updateHTMLAttrs(\"body\", \"class\", newValue > 0 ? modalOpenClassName : \"\");\n  });\n  return {\n    ...modalManagerPlugin,\n    dispose\n  };\n};\nconst useModalManager = (modalOpen, initialValue) => {\n  const {\n    pushRegistry,\n    pushStack,\n    removeStack,\n    stack,\n    dispose,\n    countStack\n  } = useSharedModalStack();\n  const currentModal = getCurrentInstance();\n  if (!currentModal || currentModal.type.__name !== \"BModal\") {\n    throw new Error(\"useModalManager must only use in BModal component\");\n  }\n  pushRegistry == null ? void 0 : pushRegistry(currentModal);\n  tryOnScopeDispose(() => {\n    dispose(currentModal);\n  });\n  const setInStack = (newValue, oldValue) => {\n    if (newValue) {\n      pushStack == null ? void 0 : pushStack(currentModal);\n    } else if (oldValue && !newValue) {\n      removeStack == null ? void 0 : removeStack(currentModal);\n    }\n  };\n  setInStack(initialValue, initialValue);\n  watch(modalOpen, setInStack);\n  return {\n    activePosition: computed(() => stack == null ? void 0 : stack.value.findIndex(el => {\n      var _a, _b;\n      return toValue((_a = el.exposed) == null ? void 0 : _a.id) === toValue((_b = currentModal.exposed) == null ? void 0 : _b.id);\n    })),\n    activeModalCount: countStack,\n    stackWithoutSelf: computed(() => (stack == null ? void 0 : stack.value.filter(el => {\n      var _a, _b;\n      return toValue((_a = el.exposed) == null ? void 0 : _a.id) !== toValue((_b = currentModal.exposed) == null ? void 0 : _b.id);\n    })) ?? [])\n  };\n};\nexport { useModalManager as a, useSharedModalStack as u };","map":{"version":3,"names":["modalOpenClassName","useSharedModalStack","modalManagerPlugin","inject","modalManagerPluginKey","dispose","modal","removeStack","removeRegistry","updateHTMLAttrs","getSSRHandler","selector","attribute","value","el","window","document","querySelector","unrefElement","classList","toggle","setAttribute","tryOnScopeDispose","watch","countStack","newValue","useModalManager","modalOpen","initialValue","pushRegistry","pushStack","stack","currentModal","getCurrentInstance","type","__name","Error","setInStack","oldValue","activePosition","computed","findIndex","toValue","_a","exposed","id","_b","activeModalCount","stackWithoutSelf","filter"],"sources":["../src/composables/useModalManager.ts"],"sourcesContent":["import {getSSRHandler, tryOnScopeDispose, unrefElement} from '@vueuse/core'\nimport {\n  type ComponentInternalInstance,\n  computed,\n  getCurrentInstance,\n  inject,\n  type Ref,\n  toValue,\n  watch,\n} from 'vue'\nimport {modalManagerPluginKey} from '../utils/keys'\n\nconst modalOpenClassName = 'modal-open'\n\nexport const useSharedModalStack = () => {\n  const modalManagerPlugin = inject(modalManagerPluginKey)\n\n  /**\n   * Removes an item from both the stack and registry\n   */\n  const dispose = (modal: Readonly<ComponentInternalInstance>): void => {\n    modalManagerPlugin?.removeStack(modal)\n    modalManagerPlugin?.removeRegistry(modal)\n  }\n\n  const updateHTMLAttrs = getSSRHandler('updateHTMLAttrs', (selector, attribute, value) => {\n    const el =\n      typeof selector === 'string'\n        ? window?.document.querySelector(selector)\n        : unrefElement(selector)\n    if (!el) return\n\n    if (attribute === 'class') {\n      el.classList.toggle(modalOpenClassName, value === modalOpenClassName)\n    } else {\n      el.setAttribute(attribute, value)\n    }\n  })\n\n  tryOnScopeDispose(() => {\n    updateHTMLAttrs('body', 'class', '')\n  })\n\n  watch(\n    () => modalManagerPlugin?.countStack.value,\n    (newValue) => {\n      if (newValue === undefined) return\n      updateHTMLAttrs('body', 'class', newValue > 0 ? modalOpenClassName : '')\n    }\n  )\n\n  return {\n    ...modalManagerPlugin,\n    dispose,\n  }\n}\n\nexport const useModalManager = (modalOpen: Readonly<Ref<boolean>>, initialValue: boolean) => {\n  const {pushRegistry, pushStack, removeStack, stack, dispose, countStack} = useSharedModalStack()\n\n  const currentModal = getCurrentInstance()\n\n  if (!currentModal || currentModal.type.__name !== 'BModal') {\n    throw new Error('useModalManager must only use in BModal component')\n  }\n\n  pushRegistry?.(currentModal)\n\n  tryOnScopeDispose(() => {\n    dispose(currentModal)\n  })\n\n  const setInStack = (newValue: boolean, oldValue: boolean) => {\n    if (newValue) {\n      pushStack?.(currentModal)\n    } else if (oldValue && !newValue) {\n      removeStack?.(currentModal)\n    }\n  }\n\n  // (initialValue, initialValue) is meant to always only ever trigger the first `if (newValue) {` block. The other block is skipped _always_\n  setInStack(initialValue, initialValue)\n\n  watch(modalOpen, setInStack)\n\n  return {\n    activePosition: computed(() =>\n      stack?.value.findIndex((el) => toValue(el.exposed?.id) === toValue(currentModal.exposed?.id))\n    ),\n    activeModalCount: countStack,\n    stackWithoutSelf: computed(\n      () =>\n        stack?.value.filter(\n          (el) => toValue(el.exposed?.id) !== toValue(currentModal.exposed?.id)\n        ) ?? []\n    ),\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}