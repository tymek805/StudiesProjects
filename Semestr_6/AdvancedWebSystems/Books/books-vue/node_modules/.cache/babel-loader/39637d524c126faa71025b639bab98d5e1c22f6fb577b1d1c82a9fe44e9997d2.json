{"ast":null,"code":"import \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nfunction findProvides(binding, vnode) {\n  var _a, _b;\n  const provides = (vnode.ctx === binding.instance.$ ? (_a = findComponentParent(vnode, binding.instance.$)) == null ? void 0 : _a.provides : (_b = vnode.ctx) == null ? void 0 : _b.provides) ?? binding.instance.$.provides;\n  return provides;\n}\nfunction findComponentParent(vnode, root) {\n  const stack = /* @__PURE__ */new Set();\n  const walk = children => {\n    var _a, _b;\n    for (const child of children) {\n      if (!child) continue;\n      if (child === vnode || child.el && vnode.el && child.el === vnode.el) {\n        return true;\n      }\n      stack.add(child);\n      let result2;\n      if (child.suspense) {\n        result2 = walk([child.ssContent]);\n      } else if (Array.isArray(child.children)) {\n        result2 = walk(child.children);\n      } else if ((_a = child.component) == null ? void 0 : _a.vnode) {\n        result2 = walk([(_b = child.component) == null ? void 0 : _b.subTree]);\n      }\n      if (result2) {\n        return result2;\n      }\n      stack.delete(child);\n    }\n    return false;\n  };\n  if (!walk([root.subTree])) {\n    console.error(\"Could not find original vnode,  will not inherit provides\");\n    return root;\n  }\n  const result = Array.from(stack).reverse();\n  for (const child of result) {\n    if (child.component) {\n      return child.component;\n    }\n  }\n  return root;\n}\nexport { findProvides as f };","map":{"version":3,"names":["findProvides","binding","vnode","_a","_b","provides","ctx","instance","$","findComponentParent","root","stack","Set","walk","children","child","el","add","result2","suspense","ssContent","Array","isArray","component","subTree","delete","console","error","result","from","reverse"],"sources":["../src/directives/utils.ts"],"sourcesContent":["import type {ComponentInternalInstance, DirectiveBinding, VNode} from 'vue'\n\ninterface _ComponentInternalInstance extends ComponentInternalInstance {\n  provides?: Record<string, unknown>\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  setupState?: any\n}\n\ninterface _VNode extends VNode {\n  ctx?: _ComponentInternalInstance | null\n  ssContent?: VNode | null\n}\n\n// taken from vuetify https://github.com/vuetifyjs/vuetify/blob/master/packages/vuetify/src/composables/directiveComponent.ts\n\nexport function findProvides(binding: DirectiveBinding, vnode: _VNode): Record<string, unknown> {\n  const provides =\n    (vnode.ctx === binding.instance!.$\n      ? findComponentParent(vnode, binding.instance!.$)?.provides\n      : vnode.ctx?.provides) ?? binding.instance!.$.provides\n\n  return provides\n}\n\nexport function findComponentParent(\n  vnode: VNode,\n  root: ComponentInternalInstance\n): _ComponentInternalInstance | null {\n  // Walk the tree from root until we find the child vnode\n  const stack = new Set<VNode>()\n  const walk = (children: _VNode[]): boolean => {\n    for (const child of children) {\n      if (!child) continue\n\n      if (child === vnode || (child.el && vnode.el && child.el === vnode.el)) {\n        return true\n      }\n\n      stack.add(child)\n      let result\n      if (child.suspense) {\n        result = walk([child.ssContent!])\n      } else if (Array.isArray(child.children)) {\n        result = walk(child.children as VNode[])\n      } else if (child.component?.vnode) {\n        result = walk([child.component?.subTree])\n      }\n      if (result) {\n        return result\n      }\n      stack.delete(child)\n    }\n\n    return false\n  }\n  if (!walk([root.subTree])) {\n    // eslint-disable-next-line no-console\n    console.error('Could not find original vnode,  will not inherit provides')\n    return root\n  }\n\n  // Return the first component parent\n  const result = Array.from(stack).reverse()\n  for (const child of result) {\n    if (child.component) {\n      return child.component\n    }\n  }\n  return root\n}\n"],"mappings":";;;;;;;AAegB,SAAAA,aAAaC,OAAA,EAA2BC,KAAA,EAAwC;EAAhF,IAAAC,EAAA,EAAAC,EAAA;EACd,MAAMC,QAAA,IACHH,KAAA,CAAMI,GAAA,KAAQL,OAAA,CAAQM,QAAA,CAAUC,CAAA,IAC7BL,EAAA,GAAAM,mBAAA,CAAoBP,KAAA,EAAOD,OAAA,CAAQM,QAAA,CAAUC,CAAC,MAA9C,gBAAAL,EAAA,CAAiDE,QAAA,IACjDD,EAAA,GAAAF,KAAA,CAAMI,GAAA,KAAN,gBAAAF,EAAA,CAAWC,QAAA,KAAaJ,OAAA,CAAQM,QAAA,CAAUC,CAAA,CAAEH,QAAA;EAE3C,OAAAA,QAAA;AACT;AAEgB,SAAAI,oBACdP,KAAA,EACAQ,IAAA,EACmC;EAE7B,MAAAC,KAAA,sBAAYC,GAAA,CAAW;EACvB,MAAAC,IAAA,GAAQC,QAAA,IAAgC;IAfhC,IAAAX,EAAA,EAAAC,EAAA;IAgBZ,WAAWW,KAAA,IAASD,QAAA,EAAU;MAC5B,IAAI,CAACC,KAAA,EAAO;MAER,IAAAA,KAAA,KAAUb,KAAA,IAAUa,KAAA,CAAMC,EAAA,IAAMd,KAAA,CAAMc,EAAA,IAAMD,KAAA,CAAMC,EAAA,KAAOd,KAAA,CAAMc,EAAA,EAAK;QAC/D;MAAA;MAGTL,KAAA,CAAMM,GAAA,CAAIF,KAAK;MACX,IAAAG,OAAA;MACJ,IAAIH,KAAA,CAAMI,QAAA,EAAU;QAClBD,OAAA,GAASL,IAAA,CAAK,CAACE,KAAA,CAAMK,SAAU,CAAC;MACvB,WAAAC,KAAA,CAAMC,OAAA,CAAQP,KAAA,CAAMD,QAAQ,GAAG;QACxCI,OAAA,GAASL,IAAA,CAAKE,KAAA,CAAMD,QAAmB;MAAA,YAC9BX,EAAA,GAAAY,KAAA,CAAMQ,SAAA,KAAN,gBAAApB,EAAA,CAAiBD,KAAA,EAAO;QACjCgB,OAAA,GAASL,IAAA,CAAK,EAACT,EAAA,GAAAW,KAAA,CAAMQ,SAAA,KAAN,gBAAAnB,EAAA,CAAiBoB,OAAO,CAAC;MAAA;MAE1C,IAAIN,OAAA,EAAQ;QACH,OAAAA,OAAA;MAAA;MAETP,KAAA,CAAMc,MAAA,CAAOV,KAAK;IAAA;IAGb;EACT;EACA,IAAI,CAACF,IAAA,CAAK,CAACH,IAAA,CAAKc,OAAO,CAAC,GAAG;IAEzBE,OAAA,CAAQC,KAAA,CAAM,2DAA2D;IAClE,OAAAjB,IAAA;EAAA;EAIT,MAAMkB,MAAA,GAASP,KAAA,CAAMQ,IAAA,CAAKlB,KAAK,EAAEmB,OAAA,CAAQ;EACzC,WAAWf,KAAA,IAASa,MAAA,EAAQ;IAC1B,IAAIb,KAAA,CAAMQ,SAAA,EAAW;MACnB,OAAOR,KAAA,CAAMQ,SAAA;IAAA;EACf;EAEK,OAAAb,IAAA;AACT","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}