{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nconst omit = (objToPluck, keysToPluck) => Object.keys(objToPluck).filter(key => !keysToPluck.map(el => el.toString()).includes(key)).reduce((result, key) => ({\n  ...result,\n  [key]: objToPluck[key]\n}), {});\nconst pick = (objToPluck, keysToPluck) => [...keysToPluck].reduce((memo, prop) => {\n  memo[prop] = objToPluck[prop];\n  return memo;\n}, {});\nconst get = (value, path, defaultValue) => {\n  const segments = path.split(/[.[\\]]/g);\n  let current = value;\n  for (const key of segments) {\n    if (current === null) return defaultValue;\n    if (current === void 0) return defaultValue;\n    if (key.trim() === \"\") continue;\n    current = current[key];\n  }\n  if (current === void 0) return defaultValue;\n  return current;\n};\nconst set = (initial, path, value) => {\n  const clone = obj => {\n    const isPrimitive = value2 => value2 === void 0 || value2 === null || typeof value2 !== \"object\" && typeof value2 !== \"function\";\n    if (isPrimitive(obj)) {\n      return obj;\n    }\n    if (typeof obj === \"function\") {\n      return obj.bind({});\n    }\n    const newObj = new obj.constructor();\n    Object.getOwnPropertyNames(obj).forEach(prop => {\n      newObj[prop] = obj[prop];\n    });\n    return newObj;\n  };\n  const toInt = (value2, defaultValue) => {\n    const def = defaultValue;\n    if (value2 === null || value2 === void 0) {\n      return def;\n    }\n    const result = Number.parseInt(value2);\n    return Number.isNaN(result) ? def : result;\n  };\n  if (!initial) return {};\n  if (!path || value === void 0) return initial;\n  const segments = path.split(/[.[\\]]/g).filter(x => !!x.trim());\n  const _set = node => {\n    if (segments.length > 1) {\n      const key = segments.shift();\n      const nextIsNum = toInt(segments[0], null) === null ? false : true;\n      node[key] = node[key] === void 0 ? nextIsNum ? [] : {} : node[key];\n      _set(node[key]);\n    } else {\n      node[segments[0]] = value;\n    }\n  };\n  const cloned = clone(initial);\n  _set(cloned);\n  return cloned;\n};\nexport { get as g, omit as o, pick as p, set as s };","map":{"version":3,"names":["omit","objToPluck","keysToPluck","Object","keys","filter","key","map","el","toString","includes","reduce","result","pick","memo","prop","get","value","path","defaultValue","segments","split","current","trim","set","initial","clone","obj","isPrimitive","value2","bind","newObj","constructor","getOwnPropertyNames","forEach","toInt","def","Number","parseInt","isNaN","x","_set","node","length","shift","nextIsNum","cloned"],"sources":["../src/utils/object.ts"],"sourcesContent":["/**\n * Removes properties from an object, based on the values in an array, and returns the new object.\n * Equivalent to an object version of TS Omit<>\n */\nexport const omit = <\n  A extends Record<PropertyKey, unknown>,\n  const B extends ReadonlyArray<PropertyKey>,\n>(\n  objToPluck: Readonly<A>,\n  keysToPluck: Readonly<B> | readonly (keyof A)[]\n): Omit<A, B[number]> =>\n  Object.keys(objToPluck)\n    .filter((key) => !keysToPluck.map((el) => el.toString()).includes(key))\n    .reduce((result, key) => ({...result, [key]: objToPluck[key]}), {} as Omit<A, B[number]>)\n\n/**\n * Picks properties from an object, base on the values in an array, and returns the new object.\n * Equivalent to an object version of TS Pick<>\n */\nexport const pick = <\n  A extends Record<PropertyKey, unknown>,\n  const B extends ReadonlyArray<PropertyKey>,\n>(\n  objToPluck: Readonly<A>,\n  keysToPluck: Readonly<B> | readonly (keyof A)[]\n): Pick<A, B[number]> =>\n  [...keysToPluck].reduce(\n    (memo, prop) => {\n      memo[prop] = objToPluck[prop]\n      return memo\n    },\n    {} as Record<PropertyKey, unknown>\n  ) as Pick<A, B[number]>\n\n/**\n * Dynamically get a nested value from an array or\n * object with a string.\n *\n * @example get(person, 'friends[0].name')\n *\n * Thanks to\n * @link https://github.com/rayepps/radash/blob/master/src/object.ts#L214\n */\nexport const get = <TDefault = unknown>(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  value: any,\n  path: string,\n  defaultValue?: Readonly<TDefault>\n): TDefault => {\n  const segments = path.split(/[.[\\]]/g)\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let current: any = value\n  for (const key of segments) {\n    if (current === null) return defaultValue as TDefault\n    if (current === undefined) return defaultValue as TDefault\n    if (key.trim() === '') continue\n    current = current[key]\n  }\n  if (current === undefined) return defaultValue as TDefault\n  return current\n}\n\n/**\n * Opposite of get, dynamically set a nested value into\n * an object using a key path. Does not modify the given\n * initial object.\n *\n * @example\n * set({}, 'name', 'ra') // => { name: 'ra' }\n * set({}, 'cards[0].value', 2) // => { cards: [{ value: 2 }] }\n *\n * Thanks to\n * @link https://github.com/rayepps/radash/blob/master/src/object.ts#L214\n */\nexport const set = <T extends object, K>(initial: T, path: string, value: K): T => {\n  const clone = <T>(obj: T): T => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const isPrimitive = (value: any): boolean =>\n      value === undefined ||\n      value === null ||\n      (typeof value !== 'object' && typeof value !== 'function')\n    // Primitive values do not need cloning.\n    if (isPrimitive(obj)) {\n      return obj\n    }\n\n    if (typeof obj === 'function') {\n      return obj.bind({})\n    }\n\n    const newObj = new ((obj as object).constructor as {new (): T})()\n\n    // Assign the props.\n    Object.getOwnPropertyNames(obj).forEach((prop) => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      ;(newObj as any)[prop] = (obj as any)[prop]\n    })\n\n    return newObj\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const toInt = <T extends number | null = number>(value: any, defaultValue?: T): number | T => {\n    const def = defaultValue === undefined ? 0 : defaultValue\n    if (value === null || value === undefined) {\n      return def\n    }\n    const result = Number.parseInt(value)\n    return Number.isNaN(result) ? def : result\n  }\n\n  if (!initial) return {} as T\n  if (!path || value === undefined) return initial\n  const segments = path.split(/[.[\\]]/g).filter((x) => !!x.trim())\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const _set = (node: any) => {\n    if (segments.length > 1) {\n      const key = segments.shift() as string\n      const nextIsNum = toInt(segments[0], null) === null ? false : true\n      node[key] = node[key] === undefined ? (nextIsNum ? [] : {}) : node[key]\n      _set(node[key])\n    } else {\n      node[segments[0]] = value\n    }\n  }\n  const cloned = clone(initial)\n  _set(cloned)\n  return cloned\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const deepEqual = (a: any, b: any): boolean => {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== 'object' || a === null || typeof b !== 'object' || b === null) {\n    return false\n  }\n\n  const keysA = Object.keys(a),\n    keysB = Object.keys(b)\n\n  if (keysA.length !== keysB.length) {\n    return false\n  }\n\n  for (const key of keysA) {\n    if (!keysB.includes(key) || !deepEqual(a[key], b[key])) {\n      return false\n    }\n  }\n\n  return true\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}