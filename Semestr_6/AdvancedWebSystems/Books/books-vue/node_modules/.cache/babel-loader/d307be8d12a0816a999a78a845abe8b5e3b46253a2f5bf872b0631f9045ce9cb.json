{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport { b as useIntersectionObserver, c as useMutationObserver } from \"../../../index-cC189kCW.mjs\";\nimport { toRef, ref, watch, getCurrentInstance, nextTick, onMounted, computed, readonly } from \"vue\";\nimport { g as getElement } from \"../../../getElement-D_JPfLJS.mjs\";\nimport { s as syncRef } from \"../../../index-CLgoGrAV.mjs\";\nconst useScrollspy = (content, target, options = {}) => {\n  const cont = toRef(content);\n  const tar = toRef(target);\n  const resolvedContent = ref(getElement(cont.value));\n  const resolvedTarget = ref(getElement(tar.value));\n  watch([cont, tar], () => {\n    updateList();\n  });\n  const {\n    contentQuery = \":scope > [id]\",\n    targetQuery = \"[href]\",\n    manual = false,\n    root,\n    rootMargin = \"0px 0px -25%\",\n    threshold = [0.1, 0.5, 1],\n    watchChanges = true\n  } = options;\n  const current = ref(null);\n  const list = ref([]);\n  const nodeList = ref([]);\n  const ctx = getCurrentInstance();\n  if (!ctx) {\n    nextTick(() => {\n      updateList();\n    });\n  } else {\n    onMounted(() => {\n      syncRef(cont, resolvedContent, {\n        transform: {\n          ltr: v => getElement(v)\n        },\n        direction: \"ltr\",\n        immediate: true\n      });\n      syncRef(tar, resolvedTarget, {\n        transform: {\n          ltr: v => getElement(v)\n        },\n        direction: \"ltr\",\n        immediate: true\n      });\n      updateList();\n    });\n  }\n  const updateList = () => {\n    nodeList.value = resolvedContent.value ? Array.from(resolvedContent.value.querySelectorAll(contentQuery)) : [];\n    list.value = nodeList.value.map(el => ({\n      id: el.id,\n      el,\n      visible: false,\n      text: el.textContent\n    }));\n  };\n  let isScrollingDown = true;\n  let previousScrollTop = 0;\n  const scrollRoot = computed(() => resolvedContent.value && getComputedStyle(resolvedContent.value).overflowY === \"visible\" ? null : resolvedContent.value);\n  const iobs = useIntersectionObserver(nodeList, entries => {\n    var _a, _b, _c, _d;\n    const scrollTop = (_a = scrollRoot.value || (document == null ? void 0 : document.documentElement)) == null ? void 0 : _a.scrollTop;\n    isScrollingDown = scrollTop > previousScrollTop;\n    previousScrollTop = scrollTop;\n    entries.forEach(entry => {\n      if (entry.isIntersecting) {\n        list.value.forEach(node => {\n          if (node.el === entry.target) {\n            node.visible = true;\n          }\n        });\n        return;\n      }\n      list.value.forEach(node => {\n        if (node.el === entry.target) {\n          node.visible = false;\n        }\n      });\n    });\n    let newId = null;\n    if (isScrollingDown) {\n      newId = ((_b = [...list.value].reverse().find(node => node.visible)) == null ? void 0 : _b.id) || null;\n    } else {\n      newId = ((_c = list.value.find(node => node.visible)) == null ? void 0 : _c.id) || null;\n    }\n    if (newId !== null) {\n      current.value = newId;\n    }\n    if (!current.value) {\n      current.value = ((_d = list.value[0]) == null ? void 0 : _d.id) || null;\n    }\n  }, {\n    root: root ? getElement(root) : scrollRoot,\n    rootMargin,\n    threshold\n  });\n  watch(current, newId => {\n    var _a;\n    if (manual) return;\n    const nodes = (_a = resolvedTarget.value) == null ? void 0 : _a.querySelectorAll(targetQuery);\n    if (nodes === void 0) return;\n    let foundParent = false;\n    let activeElement = null;\n    nodes.forEach(node => {\n      var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;\n      const parentDropdown = node.closest(\".dropdown\");\n      if ((_a2 = node.getAttribute(\"href\")) == null ? void 0 : _a2.includes(`#${newId}`)) {\n        activeElement = node;\n        node.classList.add(\"active\");\n        if (parentDropdown) {\n          (_b = parentDropdown == null ? void 0 : parentDropdown.querySelector(\".dropdown-toggle\")) == null ? void 0 : _b.classList.add(\"active\");\n          foundParent = true;\n        }\n        let parentNav = (_c = node.closest(\".nav\")) == null ? void 0 : _c.previousSibling;\n        while ((_d = parentNav == null ? void 0 : parentNav.classList) == null ? void 0 : _d.contains(\"nav-item\")) {\n          foundParent = true;\n          (_e = parentNav.querySelector(\".nav-link\")) == null ? void 0 : _e.classList.add(\"active\");\n          parentNav = (_f = parentNav.closest(\".nav\")) == null ? void 0 : _f.previousSibling;\n        }\n      } else {\n        node.classList.remove(\"active\");\n        if (parentDropdown && !foundParent) {\n          (_g = parentDropdown == null ? void 0 : parentDropdown.querySelector(\".dropdown-toggle\")) == null ? void 0 : _g.classList.remove(\"active\");\n        }\n        if (!foundParent) {\n          let parentNav = (_h = node.closest(\".nav\")) == null ? void 0 : _h.previousSibling;\n          while ((_i = parentNav == null ? void 0 : parentNav.classList) == null ? void 0 : _i.contains(\"nav-item\")) {\n            foundParent = true;\n            if (parentNav.querySelector(\".nav-link\") !== activeElement) {\n              (_j = parentNav.querySelector(\".nav-link\")) == null ? void 0 : _j.classList.remove(\"active\");\n            }\n            parentNav = (_k = parentNav.closest(\".nav\")) == null ? void 0 : _k.previousSibling;\n          }\n        }\n      }\n    });\n  });\n  const mobs = !watchChanges ? {\n    stop: () => {}\n  } : useMutationObserver(resolvedContent, () => {\n    updateList();\n  }, {\n    childList: true\n  });\n  const scrollIntoView = (event, smooth = false) => {\n    var _a, _b;\n    event.preventDefault();\n    const href = (_b = (_a = event.target) == null ? void 0 : _a.getAttribute) == null ? void 0 : _b.call(_a, \"href\");\n    const el = href ? document == null ? void 0 : document.querySelector(href) : null;\n    if (el && resolvedContent.value) {\n      if (resolvedContent.value.scrollTo) {\n        resolvedContent.value.scrollTo({\n          top: el.offsetTop,\n          behavior: smooth ? \"smooth\" : \"auto\"\n        });\n      } else {\n        resolvedContent.value.scrollTop = el.offsetTop;\n      }\n    }\n  };\n  const cleanup = () => {\n    iobs.stop();\n    mobs.stop();\n  };\n  return {\n    current: readonly(current),\n    list,\n    content: resolvedContent,\n    target: resolvedTarget,\n    scrollIntoView,\n    updateList,\n    cleanup\n  };\n};\nexport { useScrollspy };","map":{"version":3,"names":["useScrollspy","content","target","options","cont","toRef","tar","resolvedContent","ref","getElement","value","resolvedTarget","watch","updateList","contentQuery","targetQuery","manual","root","rootMargin","threshold","watchChanges","current","list","nodeList","ctx","getCurrentInstance","nextTick","onMounted","syncRef","transform","ltr","v","direction","immediate","Array","from","querySelectorAll","map","el","id","visible","text","textContent","isScrollingDown","previousScrollTop","scrollRoot","computed","getComputedStyle","overflowY","iobs","useIntersectionObserver","entries","scrollTop","_a","document","documentElement","forEach","entry","isIntersecting","node","newId","_b","reverse","find","_c","_d","nodes","foundParent","activeElement","parentDropdown","closest","_a2","getAttribute","includes","classList","add","querySelector","parentNav","previousSibling","contains","_e","_f","remove","_g","_h","_i","_j","_k","mobs","stop","useMutationObserver","childList","scrollIntoView","event","smooth","preventDefault","href","call","scrollTo","top","offsetTop","behavior","cleanup","readonly"],"sources":["../../../../src/composables/useScrollspy/index.ts"],"sourcesContent":["import {syncRef, useIntersectionObserver, useMutationObserver} from '@vueuse/core'\nimport {\n  type ComponentPublicInstance,\n  computed,\n  getCurrentInstance,\n  type MaybeRefOrGetter,\n  nextTick,\n  onMounted,\n  readonly,\n  type Ref,\n  ref,\n  toRef,\n  watch,\n} from 'vue'\nimport {getElement} from '../../utils/getElement'\n\ntype ScrollspyList = {\n  id: string | null\n  el: HTMLElement | null\n  visible: boolean\n  text: string | null\n}[]\n\ninterface ScrollspyReturn {\n  current: Readonly<Ref<string | null>>\n  list: Readonly<Ref<ScrollspyList>>\n  content: Ref<HTMLElement | undefined>\n  target: Ref<HTMLElement | undefined>\n  scrollIntoView: (event: MouseEvent) => void\n  updateList: () => void\n  cleanup: () => void\n}\n\ninterface ScrollspyOptions {\n  contentQuery: string\n  targetQuery: string\n  manual: boolean\n  root: string | ComponentPublicInstance | HTMLElement | null\n  rootMargin: string\n  threshold: number | number[]\n  watchChanges: boolean\n}\n\nexport const useScrollspy = (\n  content: MaybeRefOrGetter<string | ComponentPublicInstance | HTMLElement | null>,\n  target: MaybeRefOrGetter<string | ComponentPublicInstance | HTMLElement | null>,\n  options: Readonly<Partial<ScrollspyOptions>> = {}\n): ScrollspyReturn => {\n  const cont = toRef(content)\n  const tar = toRef(target)\n\n  const resolvedContent = ref(getElement(cont.value))\n  const resolvedTarget = ref(getElement(tar.value))\n\n  watch([cont, tar], () => {\n    updateList()\n  })\n  const {\n    contentQuery = ':scope > [id]',\n    targetQuery = '[href]',\n    manual = false,\n    root,\n    rootMargin = '0px 0px -25%',\n    threshold = [0.1, 0.5, 1],\n    watchChanges = true,\n  } = options\n  const current = ref<string | null>(null)\n  const list = ref<ScrollspyList>([])\n  const nodeList = ref<HTMLElement[]>([])\n\n  // are we called in directive?\n  const ctx = getCurrentInstance()\n  if (!ctx) {\n    nextTick(() => {\n      updateList()\n    })\n  } else {\n    onMounted(() => {\n      syncRef(cont, resolvedContent, {\n        transform: {\n          ltr: (v) => getElement(v),\n        },\n        direction: 'ltr',\n        immediate: true,\n      })\n      syncRef(tar, resolvedTarget, {\n        transform: {\n          ltr: (v) => getElement(v),\n        },\n        direction: 'ltr',\n        immediate: true,\n      })\n      updateList()\n    })\n  }\n\n  const updateList = () => {\n    nodeList.value = resolvedContent.value\n      ? (Array.from(resolvedContent.value.querySelectorAll(contentQuery)) as HTMLElement[])\n      : []\n    list.value = nodeList.value.map((el) => ({\n      id: el.id,\n      el,\n      visible: false,\n      text: el.textContent,\n    }))\n  }\n\n  let isScrollingDown = true\n  let previousScrollTop = 0\n  const scrollRoot = computed(() =>\n    resolvedContent.value && getComputedStyle(resolvedContent.value).overflowY === 'visible'\n      ? null\n      : resolvedContent.value\n  )\n\n  const iobs = useIntersectionObserver(\n    nodeList,\n    (entries) => {\n      const scrollTop = (scrollRoot.value || document?.documentElement)?.scrollTop\n      isScrollingDown = scrollTop > previousScrollTop\n      previousScrollTop = scrollTop\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          list.value.forEach((node) => {\n            if (node.el === entry.target) {\n              node.visible = true\n            }\n          })\n          return\n        }\n        list.value.forEach((node) => {\n          if (node.el === entry.target) {\n            node.visible = false\n          }\n        })\n      })\n      let newId: string | null = null\n      if (isScrollingDown) {\n        newId = [...list.value].reverse().find((node) => node.visible)?.id || null\n      } else {\n        newId = list.value.find((node) => node.visible)?.id || null\n      }\n      if (newId !== null) {\n        current.value = newId\n      }\n      if (!current.value) {\n        current.value = list.value[0]?.id || null\n      }\n    },\n    {\n      root: root ? getElement(root) : scrollRoot,\n      rootMargin,\n      threshold,\n    }\n  )\n  watch(current, (newId) => {\n    if (manual) return\n    const nodes = resolvedTarget.value?.querySelectorAll(targetQuery)\n    if (nodes === undefined) return\n    let foundParent = false\n    let activeElement: HTMLElement | null = null\n    nodes.forEach((node) => {\n      const parentDropdown = node.closest('.dropdown')\n\n      if (node.getAttribute('href')?.includes(`#${newId}`)) {\n        activeElement = node as HTMLElement\n        node.classList.add('active')\n        if (parentDropdown) {\n          parentDropdown?.querySelector('.dropdown-toggle')?.classList.add('active')\n          foundParent = true\n        }\n        let parentNav = node.closest('.nav')?.previousSibling as HTMLElement\n        while (parentNav?.classList?.contains('nav-item')) {\n          foundParent = true\n          parentNav.querySelector('.nav-link')?.classList.add('active')\n          parentNav = parentNav.closest('.nav')?.previousSibling as HTMLElement\n        }\n      } else {\n        node.classList.remove('active')\n        if (parentDropdown && !foundParent) {\n          parentDropdown?.querySelector('.dropdown-toggle')?.classList.remove('active')\n        }\n\n        if (!foundParent) {\n          let parentNav = node.closest('.nav')?.previousSibling as HTMLElement\n          while (parentNav?.classList?.contains('nav-item')) {\n            foundParent = true\n            if (parentNav.querySelector('.nav-link') !== activeElement) {\n              parentNav.querySelector('.nav-link')?.classList.remove('active')\n            }\n            parentNav = parentNav.closest('.nav')?.previousSibling as HTMLElement\n          }\n        }\n      }\n    })\n  })\n\n  const mobs = !watchChanges\n    ? {stop: () => {}}\n    : useMutationObserver(\n        resolvedContent,\n        () => {\n          updateList()\n        },\n        {\n          childList: true,\n        }\n      )\n  const scrollIntoView = (event: Readonly<MouseEvent>, smooth: boolean = false) => {\n    event.preventDefault()\n    const href = (event.target as HTMLElement)?.getAttribute?.('href')\n    const el: HTMLElement | null = href ? document?.querySelector(href) : null\n    // console.log('scrollIntoView', event, el, content.value.$el)\n    if (el && resolvedContent.value) {\n      if (resolvedContent.value.scrollTo) {\n        resolvedContent.value.scrollTo({top: el.offsetTop, behavior: smooth ? 'smooth' : 'auto'})\n      } else {\n        resolvedContent.value.scrollTop = el.offsetTop\n      }\n    }\n  }\n  const cleanup = () => {\n    iobs.stop()\n    mobs.stop()\n  }\n  return {\n    current: readonly(current),\n    list,\n    content: resolvedContent,\n    target: resolvedTarget,\n    scrollIntoView,\n    updateList,\n    cleanup,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}